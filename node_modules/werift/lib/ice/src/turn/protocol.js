"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeIntegrityKey = exports.createTurnEndpoint = void 0;
const crypto_1 = require("crypto");
const jspack_1 = require("@shinyoshiaki/jspack");
const debug_1 = __importDefault(require("debug"));
const p_cancelable_1 = __importDefault(require("p-cancelable"));
const rx_mini_1 = __importDefault(require("rx.mini"));
const promises_1 = require("timers/promises");
const src_1 = require("../../../common/src");
const exceptions_1 = require("../exceptions");
const helper_1 = require("../helper");
const const_1 = require("../stun/const");
const message_1 = require("../stun/message");
const transaction_1 = require("../stun/transaction");
const transport_1 = require("../transport");
const log = (0, debug_1.default)("werift-ice:packages/ice/src/turn/protocol.ts");
const DEFAULT_CHANNEL_REFRESH_TIME = 500;
const DEFAULT_ALLOCATION_LIFETIME = 600;
const TCP_TRANSPORT = 0x06000000;
const UDP_TRANSPORT = 0x11000000;
class TurnTransport {
    constructor(turn) {
        Object.defineProperty(this, "turn", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: turn
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "turn"
        });
        Object.defineProperty(this, "localCandidate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "receiver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "datagramReceived", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (data, addr) => {
                try {
                    const message = (0, message_1.parseMessage)(data);
                    if (!message) {
                        this.receiver?.dataReceived(data, this.localCandidate.component);
                        return;
                    }
                    if ((message?.messageClass === const_1.classes.RESPONSE ||
                        message?.messageClass === const_1.classes.ERROR) &&
                        this.turn.transactions[message.transactionIdHex]) {
                        const transaction = this.turn.transactions[message.transactionIdHex];
                        transaction.responseReceived(message, addr);
                    }
                    else if (message?.messageClass === const_1.classes.REQUEST) {
                        this.receiver?.requestReceived(message, addr, this, data);
                    }
                }
                catch (error) {
                    log("datagramReceived error", error);
                }
            }
        });
        turn.onDatagramReceived = this.datagramReceived;
    }
    async request(request, addr, integrityKey) {
        if (this.turn.transactions[request.transactionIdHex])
            throw new Error("exist");
        if (integrityKey) {
            request.addMessageIntegrity(integrityKey);
            request.addFingerprint();
        }
        const transaction = new transaction_1.Transaction(request, addr, this);
        this.turn.transactions[request.transactionIdHex] = transaction;
        try {
            return await transaction.run();
        }
        catch (e) {
            throw e;
        }
        finally {
            delete this.turn.transactions[request.transactionIdHex];
        }
    }
    async connectionMade() { }
    async sendData(data, addr) {
        await this.turn.sendData(data, addr);
    }
    async sendStun(message, addr) {
        await this.turn.sendData(message.bytes, addr);
    }
}
class TurnClient {
    constructor(server, username, password, lifetime, transport, options = {}) {
        Object.defineProperty(this, "server", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: server
        });
        Object.defineProperty(this, "username", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: username
        });
        Object.defineProperty(this, "password", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: password
        });
        Object.defineProperty(this, "lifetime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: lifetime
        });
        Object.defineProperty(this, "transport", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: transport
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "inner_turn"
        });
        Object.defineProperty(this, "onData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new rx_mini_1.default()
        });
        Object.defineProperty(this, "transactions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "integrityKey", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "nonce", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "realm", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "relayedAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "mappedAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "refreshHandle", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "channelNumber", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0x4000
        });
        Object.defineProperty(this, "channelByAddr", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "addrByChannel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "localCandidate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**sec */
        Object.defineProperty(this, "channelRefreshTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this.options.channelRefreshTime ?? DEFAULT_CHANNEL_REFRESH_TIME
        });
        Object.defineProperty(this, "onDatagramReceived", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => { }
        });
        Object.defineProperty(this, "channelBinding", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "channelRefreshAt", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "refresh", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (exp) => new p_cancelable_1.default(async (_, f, onCancel) => {
                let run = true;
                onCancel(() => {
                    run = false;
                    f("cancel");
                });
                while (run) {
                    // refresh before expire
                    const delay = (5 / 6) * exp * 1000;
                    log("refresh delay", delay, { exp });
                    await (0, promises_1.setTimeout)(delay);
                    const request = new message_1.Message(const_1.methods.REFRESH, const_1.classes.REQUEST);
                    request.setAttribute("LIFETIME", exp);
                    try {
                        const [message] = await this.requestWithRetry(request, this.server);
                        exp = message.getAttributeValue("LIFETIME");
                        log("refresh", { exp });
                    }
                    catch (error) {
                        log("refresh error", error);
                    }
                }
            })
        });
    }
    async connectionMade() {
        this.transport.onData = (data, addr) => {
            this.datagramReceived(data, addr);
        };
    }
    handleChannelData(data) {
        const [channel, length] = jspack_1.jspack.Unpack("!HH", data.slice(0, 4));
        const addr = this.addrByChannel[channel];
        if (addr) {
            const payload = data.subarray(4, 4 + length);
            this.onDatagramReceived(payload, addr);
            this.onData.execute(payload, addr);
        }
    }
    handleSTUNMessage(data, addr) {
        try {
            const message = (0, message_1.parseMessage)(data);
            if (!message)
                throw new Error("not stun message");
            if (message.messageClass === const_1.classes.RESPONSE ||
                message.messageClass === const_1.classes.ERROR) {
                const transaction = this.transactions[message.transactionIdHex];
                if (transaction) {
                    transaction.responseReceived(message, addr);
                }
            }
            else if (message.messageClass === const_1.classes.REQUEST) {
                this.onDatagramReceived(data, addr);
            }
            if (message.getAttributeValue("DATA")) {
                const buf = message.getAttributeValue("DATA");
                this.onDatagramReceived(buf, addr);
                this.onData.execute(buf, addr);
            }
        }
        catch (error) {
            log("parse error", data.toString());
        }
    }
    datagramReceived(data, addr) {
        if (data.length >= 4 && isChannelData(data)) {
            this.handleChannelData(data);
        }
        else {
            this.handleSTUNMessage(data, addr);
        }
    }
    async connect() {
        const request = new message_1.Message(const_1.methods.ALLOCATE, const_1.classes.REQUEST);
        request
            .setAttribute("LIFETIME", this.lifetime)
            .setAttribute("REQUESTED-TRANSPORT", UDP_TRANSPORT);
        const [response] = await this.requestWithRetry(request, this.server).catch((e) => {
            log("connect error", e);
            throw e;
        });
        this.relayedAddress = response.getAttributeValue("XOR-RELAYED-ADDRESS");
        this.mappedAddress = response.getAttributeValue("XOR-MAPPED-ADDRESS");
        const exp = response.getAttributeValue("LIFETIME");
        log("connect", this.relayedAddress, this.mappedAddress, { exp });
        this.refreshHandle = (0, helper_1.future)(this.refresh(exp));
    }
    async createPermission(peerAddress) {
        const request = new message_1.Message(const_1.methods.CREATE_PERMISSION, const_1.classes.REQUEST);
        request
            .setAttribute("XOR-PEER-ADDRESS", peerAddress)
            .setAttribute("USERNAME", this.username)
            .setAttribute("REALM", this.realm)
            .setAttribute("NONCE", this.nonce);
        const [response] = await this.request(request, this.server).catch((e) => {
            request;
            throw e;
        });
        return response;
    }
    async request(request, addr) {
        if (this.transactions[request.transactionIdHex]) {
            throw new Error("exist");
        }
        if (this.integrityKey) {
            request
                .setAttribute("USERNAME", this.username)
                .setAttribute("REALM", this.realm)
                .setAttribute("NONCE", this.nonce)
                .addMessageIntegrity(this.integrityKey)
                .addFingerprint();
        }
        const transaction = new transaction_1.Transaction(request, addr, this);
        this.transactions[request.transactionIdHex] = transaction;
        try {
            return await transaction.run();
        }
        catch (e) {
            throw e;
        }
        finally {
            delete this.transactions[request.transactionIdHex];
        }
    }
    async requestWithRetry(request, addr) {
        let message, address;
        try {
            [message, address] = await this.request(request, addr);
        }
        catch (error) {
            if (error instanceof exceptions_1.TransactionFailed == false) {
                log("requestWithRetry error", error);
                throw error;
            }
            // resolve dns address
            this.server = error.addr;
            const [errorCode] = error.response.getAttributeValue("ERROR-CODE");
            const nonce = error.response.getAttributeValue("NONCE");
            const realm = error.response.getAttributeValue("REALM");
            if (((errorCode === 401 && realm) || (errorCode === 438 && this.realm)) &&
                nonce) {
                log("retry with nonce", errorCode);
                this.nonce = nonce;
                if (errorCode === 401) {
                    this.realm = realm;
                }
                this.integrityKey = makeIntegrityKey(this.username, this.realm, this.password);
                request.transactionId = (0, helper_1.randomTransactionId)();
                [message, address] = await this.request(request, this.server);
            }
            else {
                throw error;
            }
        }
        return [message, address];
    }
    async sendData(data, addr) {
        const channel = await this.getChannel(addr);
        const header = jspack_1.jspack.Pack("!HH", [channel.number, data.length]);
        this.transport.send(Buffer.concat([Buffer.from(header), data]), this.server);
    }
    async getChannel(addr) {
        if (this.channelBinding) {
            await this.channelBinding;
        }
        let channel = this.channelByAddr[addr.join("")];
        if (!channel) {
            this.channelByAddr[addr.join("")] = {
                number: this.channelNumber++,
                address: addr,
            };
            channel = this.channelByAddr[addr.join("")];
            this.addrByChannel[channel.number] = addr;
            this.channelBinding = this.channelBind(channel.number, addr);
            await this.channelBinding.catch((e) => {
                log("channelBind error", e);
                throw e;
            });
            this.channelRefreshAt = (0, src_1.int)(Date.now() / 1000) + this.channelRefreshTime;
            this.channelBinding = undefined;
            log("channelBind", channel);
        }
        else if (this.channelRefreshAt < (0, src_1.int)(Date.now() / 1000)) {
            this.channelBinding = this.channelBind(channel.number, addr);
            this.channelRefreshAt = (0, src_1.int)(Date.now() / 1000) + this.channelRefreshTime;
            await this.channelBinding.catch((e) => {
                log("channelBind error", e);
                throw e;
            });
            this.channelBinding = undefined;
            log("channelBind refresh", channel);
        }
        return channel;
    }
    async channelBind(channelNumber, addr) {
        const request = new message_1.Message(const_1.methods.CHANNEL_BIND, const_1.classes.REQUEST);
        request
            .setAttribute("CHANNEL-NUMBER", channelNumber)
            .setAttribute("XOR-PEER-ADDRESS", addr);
        const [response] = await this.requestWithRetry(request, this.server);
        if (response.messageMethod !== const_1.methods.CHANNEL_BIND) {
            throw new Error("should be CHANNEL_BIND");
        }
    }
    async sendStun(message, addr) {
        await this.transport.send(message.bytes, addr);
    }
}
async function createTurnEndpoint(serverAddr, username, password, { lifetime, portRange, interfaceAddresses, }) {
    if (lifetime == undefined) {
        lifetime = DEFAULT_ALLOCATION_LIFETIME;
    }
    const transport = await transport_1.UdpTransport.init("udp4", portRange, interfaceAddresses);
    const turnClient = new TurnClient(serverAddr, username, password, lifetime, transport);
    await turnClient.connectionMade();
    await turnClient.connect();
    const turnTransport = new TurnTransport(turnClient);
    return turnTransport;
}
exports.createTurnEndpoint = createTurnEndpoint;
function makeIntegrityKey(username, realm, password) {
    return (0, crypto_1.createHash)("md5")
        .update(Buffer.from([username, realm, password].join(":")))
        .digest();
}
exports.makeIntegrityKey = makeIntegrityKey;
function isChannelData(data) {
    return (data[0] & 0xc0) == 0x40;
}
//# sourceMappingURL=protocol.js.map