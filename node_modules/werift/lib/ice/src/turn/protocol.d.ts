/// <reference types="node" />
import PCancelable from "p-cancelable";
import Event from "rx.mini";
import type { InterfaceAddresses } from "../../../common/src/network";
import type { Candidate } from "../candidate";
import { type Future } from "../helper";
import type { Connection } from "../ice";
import { Message } from "../stun/message";
import { Transaction } from "../stun/transaction";
import { type Transport } from "../transport";
import type { Address, Protocol } from "../types/model";
declare class TurnTransport implements Protocol {
    turn: TurnClient;
    readonly type = "turn";
    localCandidate: Candidate;
    receiver?: Connection;
    constructor(turn: TurnClient);
    private datagramReceived;
    request(request: Message, addr: Address, integrityKey?: Buffer): Promise<[Message, readonly [string, number]]>;
    connectionMade(): Promise<void>;
    sendData(data: Buffer, addr: Address): Promise<void>;
    sendStun(message: Message, addr: Address): Promise<void>;
}
declare class TurnClient implements Protocol {
    server: Address;
    username: string;
    password: string;
    lifetime: number;
    transport: Transport;
    options: {
        /**sec */
        channelRefreshTime?: number;
    };
    type: string;
    readonly onData: Event<[Buffer, readonly [string, number]]>;
    transactions: {
        [hexId: string]: Transaction;
    };
    integrityKey?: Buffer;
    nonce?: Buffer;
    realm?: string;
    relayedAddress: Address;
    mappedAddress: Address;
    refreshHandle?: Future;
    channelNumber: number;
    channelByAddr: {
        [addr: string]: {
            number: number;
            address: Address;
        };
    };
    addrByChannel: {
        [channel: number]: Address;
    };
    localCandidate: Candidate;
    /**sec */
    channelRefreshTime: number;
    onDatagramReceived: (data: Buffer, addr: Address) => void;
    private channelBinding?;
    channelRefreshAt: number;
    constructor(server: Address, username: string, password: string, lifetime: number, transport: Transport, options?: {
        /**sec */
        channelRefreshTime?: number;
    });
    connectionMade(): Promise<void>;
    private handleChannelData;
    private handleSTUNMessage;
    private datagramReceived;
    connect(): Promise<void>;
    createPermission(peerAddress: Address): Promise<Message>;
    refresh: (exp: number) => PCancelable<unknown>;
    request(request: Message, addr: Address): Promise<[Message, Address]>;
    requestWithRetry(request: Message, addr: Address): Promise<[Message, Address]>;
    sendData(data: Buffer, addr: Address): Promise<void>;
    getChannel(addr: Address): Promise<{
        number: number;
        address: readonly [string, number];
    }>;
    private channelBind;
    sendStun(message: Message, addr: Address): Promise<void>;
}
export declare function createTurnEndpoint(serverAddr: Address, username: string, password: string, { lifetime, portRange, interfaceAddresses, }: {
    lifetime?: number;
    ssl?: boolean;
    transport?: "udp";
    portRange?: [number, number];
    interfaceAddresses?: InterfaceAddresses;
}): Promise<TurnTransport>;
export declare function makeIntegrityKey(username: string, realm: string, password: string): Buffer;
export {};
