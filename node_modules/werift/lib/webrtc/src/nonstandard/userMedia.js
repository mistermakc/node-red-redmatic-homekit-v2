"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MediaPlayerWebm = exports.MediaPlayerMp4 = exports.getUserMedia = void 0;
const child_process_1 = require("child_process");
const dgram_1 = require("dgram");
const promises_1 = require("timers/promises");
const uuid_1 = require("uuid");
const src_1 = require("../../../common/src");
const src_2 = require("../../../rtp/src");
const track_1 = require("../media/track");
const getUserMedia = async ({ path, loop, width, height, }) => {
    const audioPort = await (0, src_1.randomPort)();
    const videoPort = await (0, src_1.randomPort)();
    if (path.endsWith(".mp4")) {
        return new MediaPlayerMp4({
            audioPort,
            videoPort,
            path,
            loop,
            width,
            height,
        });
    }
    else {
        return new MediaPlayerWebm({
            audioPort,
            videoPort,
            path,
            loop,
            width,
            height,
        });
    }
};
exports.getUserMedia = getUserMedia;
class MediaPlayer {
    constructor(props) {
        Object.defineProperty(this, "props", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: props
        });
        Object.defineProperty(this, "streamId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0, uuid_1.v4)()
        });
        Object.defineProperty(this, "audio", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new track_1.MediaStreamTrack({ kind: "audio", streamId: this.streamId })
        });
        Object.defineProperty(this, "video", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new track_1.MediaStreamTrack({ kind: "video", streamId: this.streamId })
        });
        Object.defineProperty(this, "process", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stopped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "setupTrack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (port, track) => {
                let payloadType = 0;
                const socket = (0, dgram_1.createSocket)("udp4");
                socket.bind(port);
                socket.on("message", async (buf) => {
                    const rtp = src_2.RtpPacket.deSerialize(buf);
                    if (!payloadType) {
                        payloadType = rtp.header.payloadType;
                    }
                    // detect gStreamer restarted
                    if (payloadType !== rtp.header.payloadType) {
                        payloadType = rtp.header.payloadType;
                        track.onSourceChanged.execute(rtp.header);
                    }
                    track.writeRtp(buf);
                });
            }
        });
        this.setupTrack(props.audioPort, this.audio);
        this.setupTrack(props.videoPort, this.video);
    }
    stop() {
        this.stopped = true;
        this.process.kill("SIGINT");
    }
}
class MediaPlayerMp4 extends MediaPlayer {
    async start() {
        let payloadType = 96;
        const run = async () => {
            if (payloadType > 100)
                payloadType = 96;
            let cmd = "";
            if (this.props.width && this.props.height) {
                cmd = `gst-launch-1.0 filesrc location= ${this.props.path} ! \
decodebin ! videoscale ! video/x-raw,width=${this.props.width},height=${this.props.height} ! x264enc ! \
h264parse ! rtph264pay config-interval=10 pt=${payloadType++} ! \
udpsink host=127.0.0.1 port=${this.props.videoPort}`;
            }
            else {
                cmd = `gst-launch-1.0 filesrc location= ${this.props.path} ! \
qtdemux name=d ! \
queue ! h264parse ! rtph264pay config-interval=10 pt=${payloadType++} ! \
udpsink host=127.0.0.1 port=${this.props.videoPort} d. ! \
queue ! aacparse ! avdec_aac ! audioresample ! audioconvert ! opusenc ! rtpopuspay pt=${payloadType++} ! \
udpsink host=127.0.0.1 port=${this.props.audioPort}`;
            }
            console.log(cmd);
            this.process = (0, child_process_1.exec)(cmd);
            this.process.on("error", (e) => console.error("gst error", e));
            if (this.props.loop) {
                await new Promise((r) => this.process.on("close", r));
                if (!this.stopped) {
                    run();
                }
            }
        };
        await (0, promises_1.setImmediate)();
        run();
    }
}
exports.MediaPlayerMp4 = MediaPlayerMp4;
class MediaPlayerWebm extends MediaPlayer {
    async start() {
        let payloadType = 96;
        const run = async () => {
            if (payloadType > 100)
                payloadType = 96;
            const cmd = `gst-launch-1.0 filesrc location=${this.props.path} ! matroskademux name=d \
d.video_0 ! queue ! rtpvp8pay pt=${payloadType++} ! \
udpsink host=127.0.0.1 port=${this.props.videoPort} \
d.audio_0 ! queue ! rtpopuspay pt=${payloadType++} ! \
udpsink host=127.0.0.1 port=${this.props.audioPort}`;
            this.process = (0, child_process_1.exec)(cmd);
            if (this.props.loop) {
                await new Promise((r) => this.process.on("close", r));
                if (!this.stopped) {
                    run();
                }
            }
        };
        await (0, promises_1.setImmediate)();
        run();
    }
}
exports.MediaPlayerWebm = MediaPlayerWebm;
//# sourceMappingURL=userMedia.js.map