/// <reference types="node" />
import { Direction } from "./media/rtpTransceiver";
import { MediaStreamTrack } from "./media/track";
import { RTCIceServer } from "./peerConnection";
export declare function fingerprint(file: Buffer, hashName: string): any;
export declare function isDtls(buf: Buffer): boolean;
export declare function reverseSimulcastDirection(dir: "recv" | "send"): "send" | "recv";
export declare const andDirection: (a: Direction, b: Direction) => "inactive" | "sendonly" | "recvonly" | "sendrecv";
export declare function reverseDirection(dir: Direction): Direction;
export declare const microTime: () => number;
export declare const milliTime: () => number;
export declare const timestampSeconds: () => number;
/**https://datatracker.ietf.org/doc/html/rfc3550#section-4 */
export declare const ntpTime: () => bigint;
/**
 * https://datatracker.ietf.org/doc/html/rfc3550#section-4
 * @param ntp
 * @returns 32bit
 */
export declare const compactNtp: (ntp: bigint) => number;
export declare function parseIceServers(iceServers: RTCIceServer[]): {
    stunServer: readonly [string, number] | undefined;
    turnServer: readonly [string, number] | undefined;
    turnUsername: string | undefined;
    turnPassword: string | undefined;
};
/**
 *
 * @param signatureHash
 * @param namedCurveAlgorithm necessary when use ecdsa
 */
export declare const createSelfSignedCertificate: (signatureHash: import(".").SignatureHash, namedCurveAlgorithm?: import(".").NamedCurveAlgorithms | undefined) => Promise<{
    certPem: string;
    keyPem: string;
    signatureHash: import(".").SignatureHash;
}>;
export declare class MediaStreamTrackFactory {
    static rtpSource({ port, kind, cb, }: {
        port?: number;
        kind: "audio" | "video";
        cb?: (buf: Buffer) => Buffer;
    }): Promise<readonly [MediaStreamTrack, number, () => void]>;
}
export declare const deepMerge: <T>(dst: T, src: T) => T;
